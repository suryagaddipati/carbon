# Generated from Copper.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3_")
        buf.write("\u0179\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\3\2\7\2d\n\2\f\2\16\2g\13\2\3")
        buf.write("\2\3\2\3\3\3\3\3\3\3\3\5\3o\n\3\3\4\3\4\3\5\3\5\3\5\3")
        buf.write("\5\3\5\7\5x\n\5\f\5\16\5{\13\5\3\5\3\5\3\6\3\6\3\6\3\6")
        buf.write("\5\6\u0083\n\6\3\7\3\7\3\7\3\7\3\7\7\7\u008a\n\7\f\7\16")
        buf.write("\7\u008d\13\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b\7\b\u0096\n")
        buf.write("\b\f\b\16\b\u0099\13\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\7\t")
        buf.write("\u00a2\n\t\f\t\16\t\u00a5\13\t\3\t\3\t\3\n\3\n\3\n\3\n")
        buf.write("\3\n\3\n\5\n\u00af\n\n\3\13\3\13\3\13\3\13\3\f\3\f\3\f")
        buf.write("\3\f\3\f\7\f\u00ba\n\f\f\f\16\f\u00bd\13\f\3\f\3\f\3\r")
        buf.write("\3\r\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\5\17")
        buf.write("\u00d8\n\17\3\20\3\20\3\20\3\20\3\21\3\21\3\22\3\22\3")
        buf.write("\22\3\22\3\22\3\22\3\22\3\22\5\22\u00e8\n\22\3\23\3\23")
        buf.write("\3\23\3\23\3\24\3\24\3\25\3\25\3\25\3\25\3\25\5\25\u00f5")
        buf.write("\n\25\3\26\3\26\3\26\3\26\3\27\3\27\3\30\3\30\3\30\3\30")
        buf.write("\3\31\3\31\3\32\3\32\3\32\3\32\3\33\3\33\3\33\3\33\3\34")
        buf.write("\3\34\3\34\3\34\5\34\u010f\n\34\3\35\3\35\3\35\3\35\3")
        buf.write("\36\3\36\3\36\3\36\3\37\3\37\3\37\3\37\3 \3 \3 \3 \3 ")
        buf.write("\5 \u0122\n \3 \3 \3!\3!\3!\3!\3!\3\"\3\"\3\"\3\"\3\"")
        buf.write("\3#\3#\3#\3#\3$\3$\3$\3%\6%\u0138\n%\r%\16%\u0139\3&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\5&\u014d")
        buf.write("\n&\3\'\3\'\5\'\u0151\n\'\3(\3(\3)\3)\3*\3*\3+\3+\3,\3")
        buf.write(",\3-\3-\3.\3.\3/\3/\3/\7/\u0164\n/\f/\16/\u0167\13/\3")
        buf.write("\60\3\60\3\60\7\60\u016c\n\60\f\60\16\60\u016f\13\60\3")
        buf.write("\61\3\61\3\61\7\61\u0174\n\61\f\61\16\61\u0177\13\61\3")
        buf.write("\61\2\2\62\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$")
        buf.write("&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`\2\13\3\2\27\30")
        buf.write("\3\2\31%\4\2\32\32&-\3\2.\61\3\2\62\65\3\2\31B\3\2CF\3")
        buf.write("\2\66>\3\2?B\2\u0187\2e\3\2\2\2\4n\3\2\2\2\6p\3\2\2\2")
        buf.write("\br\3\2\2\2\n\u0082\3\2\2\2\f\u0084\3\2\2\2\16\u0090\3")
        buf.write("\2\2\2\20\u009c\3\2\2\2\22\u00ae\3\2\2\2\24\u00b0\3\2")
        buf.write("\2\2\26\u00b4\3\2\2\2\30\u00c0\3\2\2\2\32\u00c6\3\2\2")
        buf.write("\2\34\u00d7\3\2\2\2\36\u00d9\3\2\2\2 \u00dd\3\2\2\2\"")
        buf.write("\u00e7\3\2\2\2$\u00e9\3\2\2\2&\u00ed\3\2\2\2(\u00f4\3")
        buf.write("\2\2\2*\u00f6\3\2\2\2,\u00fa\3\2\2\2.\u00fc\3\2\2\2\60")
        buf.write("\u0100\3\2\2\2\62\u0102\3\2\2\2\64\u0106\3\2\2\2\66\u010a")
        buf.write("\3\2\2\28\u0110\3\2\2\2:\u0114\3\2\2\2<\u0118\3\2\2\2")
        buf.write(">\u011c\3\2\2\2@\u0125\3\2\2\2B\u012a\3\2\2\2D\u012f\3")
        buf.write("\2\2\2F\u0133\3\2\2\2H\u0137\3\2\2\2J\u014c\3\2\2\2L\u0150")
        buf.write("\3\2\2\2N\u0152\3\2\2\2P\u0154\3\2\2\2R\u0156\3\2\2\2")
        buf.write("T\u0158\3\2\2\2V\u015a\3\2\2\2X\u015c\3\2\2\2Z\u015e\3")
        buf.write("\2\2\2\\\u0160\3\2\2\2^\u0168\3\2\2\2`\u0170\3\2\2\2b")
        buf.write("d\5\4\3\2cb\3\2\2\2dg\3\2\2\2ec\3\2\2\2ef\3\2\2\2fh\3")
        buf.write("\2\2\2ge\3\2\2\2hi\7\2\2\3i\3\3\2\2\2jo\5\b\5\2ko\5\20")
        buf.write("\t\2lo\5\6\4\2mo\7]\2\2nj\3\2\2\2nk\3\2\2\2nl\3\2\2\2")
        buf.write("nm\3\2\2\2o\5\3\2\2\2pq\7\\\2\2q\7\3\2\2\2rs\7\3\2\2s")
        buf.write("t\7G\2\2tu\5L\'\2uy\7J\2\2vx\5\n\6\2wv\3\2\2\2x{\3\2\2")
        buf.write("\2yw\3\2\2\2yz\3\2\2\2z|\3\2\2\2{y\3\2\2\2|}\7K\2\2}\t")
        buf.write("\3\2\2\2~\u0083\5\f\7\2\177\u0083\5\16\b\2\u0080\u0083")
        buf.write("\5\6\4\2\u0081\u0083\7]\2\2\u0082~\3\2\2\2\u0082\177\3")
        buf.write("\2\2\2\u0082\u0080\3\2\2\2\u0082\u0081\3\2\2\2\u0083\13")
        buf.write("\3\2\2\2\u0084\u0085\7\5\2\2\u0085\u0086\7G\2\2\u0086")
        buf.write("\u0087\5L\'\2\u0087\u008b\7J\2\2\u0088\u008a\5\34\17\2")
        buf.write("\u0089\u0088\3\2\2\2\u008a\u008d\3\2\2\2\u008b\u0089\3")
        buf.write("\2\2\2\u008b\u008c\3\2\2\2\u008c\u008e\3\2\2\2\u008d\u008b")
        buf.write("\3\2\2\2\u008e\u008f\7K\2\2\u008f\r\3\2\2\2\u0090\u0091")
        buf.write("\7\6\2\2\u0091\u0092\7G\2\2\u0092\u0093\5L\'\2\u0093\u0097")
        buf.write("\7J\2\2\u0094\u0096\5\"\22\2\u0095\u0094\3\2\2\2\u0096")
        buf.write("\u0099\3\2\2\2\u0097\u0095\3\2\2\2\u0097\u0098\3\2\2\2")
        buf.write("\u0098\u009a\3\2\2\2\u0099\u0097\3\2\2\2\u009a\u009b\7")
        buf.write("K\2\2\u009b\17\3\2\2\2\u009c\u009d\7\4\2\2\u009d\u009e")
        buf.write("\7G\2\2\u009e\u009f\5L\'\2\u009f\u00a3\7J\2\2\u00a0\u00a2")
        buf.write("\5\22\n\2\u00a1\u00a0\3\2\2\2\u00a2\u00a5\3\2\2\2\u00a3")
        buf.write("\u00a1\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a6\3\2\2\2")
        buf.write("\u00a5\u00a3\3\2\2\2\u00a6\u00a7\7K\2\2\u00a7\21\3\2\2")
        buf.write("\2\u00a8\u00af\5\24\13\2\u00a9\u00af\5\26\f\2\u00aa\u00af")
        buf.write("\5\30\r\2\u00ab\u00af\5\32\16\2\u00ac\u00af\5\6\4\2\u00ad")
        buf.write("\u00af\7]\2\2\u00ae\u00a8\3\2\2\2\u00ae\u00a9\3\2\2\2")
        buf.write("\u00ae\u00aa\3\2\2\2\u00ae\u00ab\3\2\2\2\u00ae\u00ac\3")
        buf.write("\2\2\2\u00ae\u00ad\3\2\2\2\u00af\23\3\2\2\2\u00b0\u00b1")
        buf.write("\7\7\2\2\u00b1\u00b2\7G\2\2\u00b2\u00b3\5L\'\2\u00b3\25")
        buf.write("\3\2\2\2\u00b4\u00b5\7\b\2\2\u00b5\u00b6\7G\2\2\u00b6")
        buf.write("\u00b7\5L\'\2\u00b7\u00bb\7J\2\2\u00b8\u00ba\5(\25\2\u00b9")
        buf.write("\u00b8\3\2\2\2\u00ba\u00bd\3\2\2\2\u00bb\u00b9\3\2\2\2")
        buf.write("\u00bb\u00bc\3\2\2\2\u00bc\u00be\3\2\2\2\u00bd\u00bb\3")
        buf.write("\2\2\2\u00be\u00bf\7K\2\2\u00bf\27\3\2\2\2\u00c0\u00c1")
        buf.write("\7\t\2\2\u00c1\u00c2\7G\2\2\u00c2\u00c3\7L\2\2\u00c3\u00c4")
        buf.write("\5\\/\2\u00c4\u00c5\7M\2\2\u00c5\31\3\2\2\2\u00c6\u00c7")
        buf.write("\7\n\2\2\u00c7\u00c8\7G\2\2\u00c8\u00c9\t\2\2\2\u00c9")
        buf.write("\33\3\2\2\2\u00ca\u00d8\5\36\20\2\u00cb\u00d8\5\62\32")
        buf.write("\2\u00cc\u00d8\5\64\33\2\u00cd\u00d8\5\66\34\2\u00ce\u00d8")
        buf.write("\58\35\2\u00cf\u00d8\5:\36\2\u00d0\u00d8\5<\37\2\u00d1")
        buf.write("\u00d8\5> \2\u00d2\u00d8\5@!\2\u00d3\u00d8\5B\"\2\u00d4")
        buf.write("\u00d8\5D#\2\u00d5\u00d8\5\6\4\2\u00d6\u00d8\7]\2\2\u00d7")
        buf.write("\u00ca\3\2\2\2\u00d7\u00cb\3\2\2\2\u00d7\u00cc\3\2\2\2")
        buf.write("\u00d7\u00cd\3\2\2\2\u00d7\u00ce\3\2\2\2\u00d7\u00cf\3")
        buf.write("\2\2\2\u00d7\u00d0\3\2\2\2\u00d7\u00d1\3\2\2\2\u00d7\u00d2")
        buf.write("\3\2\2\2\u00d7\u00d3\3\2\2\2\u00d7\u00d4\3\2\2\2\u00d7")
        buf.write("\u00d5\3\2\2\2\u00d7\u00d6\3\2\2\2\u00d8\35\3\2\2\2\u00d9")
        buf.write("\u00da\7\13\2\2\u00da\u00db\7G\2\2\u00db\u00dc\5 \21\2")
        buf.write("\u00dc\37\3\2\2\2\u00dd\u00de\t\3\2\2\u00de!\3\2\2\2\u00df")
        buf.write("\u00e8\5$\23\2\u00e0\u00e8\5\62\32\2\u00e1\u00e8\5\66")
        buf.write("\34\2\u00e2\u00e8\58\35\2\u00e3\u00e8\5:\36\2\u00e4\u00e8")
        buf.write("\5<\37\2\u00e5\u00e8\5\6\4\2\u00e6\u00e8\7]\2\2\u00e7")
        buf.write("\u00df\3\2\2\2\u00e7\u00e0\3\2\2\2\u00e7\u00e1\3\2\2\2")
        buf.write("\u00e7\u00e2\3\2\2\2\u00e7\u00e3\3\2\2\2\u00e7\u00e4\3")
        buf.write("\2\2\2\u00e7\u00e5\3\2\2\2\u00e7\u00e6\3\2\2\2\u00e8#")
        buf.write("\3\2\2\2\u00e9\u00ea\7\13\2\2\u00ea\u00eb\7G\2\2\u00eb")
        buf.write("\u00ec\5&\24\2\u00ec%\3\2\2\2\u00ed\u00ee\t\4\2\2\u00ee")
        buf.write("\'\3\2\2\2\u00ef\u00f5\5*\26\2\u00f0\u00f5\5.\30\2\u00f1")
        buf.write("\u00f5\5\62\32\2\u00f2\u00f5\5\6\4\2\u00f3\u00f5\7]\2")
        buf.write("\2\u00f4\u00ef\3\2\2\2\u00f4\u00f0\3\2\2\2\u00f4\u00f1")
        buf.write("\3\2\2\2\u00f4\u00f2\3\2\2\2\u00f4\u00f3\3\2\2\2\u00f5")
        buf.write(")\3\2\2\2\u00f6\u00f7\7\13\2\2\u00f7\u00f8\7G\2\2\u00f8")
        buf.write("\u00f9\5,\27\2\u00f9+\3\2\2\2\u00fa\u00fb\t\5\2\2\u00fb")
        buf.write("-\3\2\2\2\u00fc\u00fd\7\26\2\2\u00fd\u00fe\7G\2\2\u00fe")
        buf.write("\u00ff\5\60\31\2\u00ff/\3\2\2\2\u0100\u0101\t\6\2\2\u0101")
        buf.write("\61\3\2\2\2\u0102\u0103\7\f\2\2\u0103\u0104\7G\2\2\u0104")
        buf.write("\u0105\5F$\2\u0105\63\3\2\2\2\u0106\u0107\7\r\2\2\u0107")
        buf.write("\u0108\7G\2\2\u0108\u0109\5T+\2\u0109\65\3\2\2\2\u010a")
        buf.write("\u010b\7\16\2\2\u010b\u010e\7G\2\2\u010c\u010f\5P)\2\u010d")
        buf.write("\u010f\5X-\2\u010e\u010c\3\2\2\2\u010e\u010d\3\2\2\2\u010f")
        buf.write("\67\3\2\2\2\u0110\u0111\7\17\2\2\u0111\u0112\7G\2\2\u0112")
        buf.write("\u0113\5P)\2\u01139\3\2\2\2\u0114\u0115\7\20\2\2\u0115")
        buf.write("\u0116\7G\2\2\u0116\u0117\5P)\2\u0117;\3\2\2\2\u0118\u0119")
        buf.write("\7_\2\2\u0119\u011a\7G\2\2\u011a\u011b\5T+\2\u011b=\3")
        buf.write("\2\2\2\u011c\u011d\7\22\2\2\u011d\u011e\7G\2\2\u011e\u0121")
        buf.write("\7L\2\2\u011f\u0122\5^\60\2\u0120\u0122\5`\61\2\u0121")
        buf.write("\u011f\3\2\2\2\u0121\u0120\3\2\2\2\u0122\u0123\3\2\2\2")
        buf.write("\u0123\u0124\7M\2\2\u0124?\3\2\2\2\u0125\u0126\7\23\2")
        buf.write("\2\u0126\u0127\7G\2\2\u0127\u0128\5F$\2\u0128\u0129\7")
        buf.write("I\2\2\u0129A\3\2\2\2\u012a\u012b\7\24\2\2\u012b\u012c")
        buf.write("\7G\2\2\u012c\u012d\5F$\2\u012d\u012e\7I\2\2\u012eC\3")
        buf.write("\2\2\2\u012f\u0130\7\25\2\2\u0130\u0131\7G\2\2\u0131\u0132")
        buf.write("\5Z.\2\u0132E\3\2\2\2\u0133\u0134\5H%\2\u0134\u0135\7")
        buf.write("I\2\2\u0135G\3\2\2\2\u0136\u0138\5J&\2\u0137\u0136\3\2")
        buf.write("\2\2\u0138\u0139\3\2\2\2\u0139\u0137\3\2\2\2\u0139\u013a")
        buf.write("\3\2\2\2\u013aI\3\2\2\2\u013b\u014d\7Y\2\2\u013c\u014d")
        buf.write("\7[\2\2\u013d\u014d\7Z\2\2\u013e\u014d\7L\2\2\u013f\u014d")
        buf.write("\7M\2\2\u0140\u014d\7O\2\2\u0141\u014d\7P\2\2\u0142\u014d")
        buf.write("\7Q\2\2\u0143\u014d\7N\2\2\u0144\u014d\7R\2\2\u0145\u014d")
        buf.write("\7S\2\2\u0146\u014d\7T\2\2\u0147\u014d\7U\2\2\u0148\u014d")
        buf.write("\7V\2\2\u0149\u014d\7W\2\2\u014a\u014d\7X\2\2\u014b\u014d")
        buf.write("\5N(\2\u014c\u013b\3\2\2\2\u014c\u013c\3\2\2\2\u014c\u013d")
        buf.write("\3\2\2\2\u014c\u013e\3\2\2\2\u014c\u013f\3\2\2\2\u014c")
        buf.write("\u0140\3\2\2\2\u014c\u0141\3\2\2\2\u014c\u0142\3\2\2\2")
        buf.write("\u014c\u0143\3\2\2\2\u014c\u0144\3\2\2\2\u014c\u0145\3")
        buf.write("\2\2\2\u014c\u0146\3\2\2\2\u014c\u0147\3\2\2\2\u014c\u0148")
        buf.write("\3\2\2\2\u014c\u0149\3\2\2\2\u014c\u014a\3\2\2\2\u014c")
        buf.write("\u014b\3\2\2\2\u014dK\3\2\2\2\u014e\u0151\7Y\2\2\u014f")
        buf.write("\u0151\5N(\2\u0150\u014e\3\2\2\2\u0150\u014f\3\2\2\2\u0151")
        buf.write("M\3\2\2\2\u0152\u0153\t\7\2\2\u0153O\3\2\2\2\u0154\u0155")
        buf.write("\7Z\2\2\u0155Q\3\2\2\2\u0156\u0157\7[\2\2\u0157S\3\2\2")
        buf.write("\2\u0158\u0159\5V,\2\u0159U\3\2\2\2\u015a\u015b\t\b\2")
        buf.write("\2\u015bW\3\2\2\2\u015c\u015d\t\t\2\2\u015dY\3\2\2\2\u015e")
        buf.write("\u015f\t\n\2\2\u015f[\3\2\2\2\u0160\u0165\5L\'\2\u0161")
        buf.write("\u0162\7N\2\2\u0162\u0164\5L\'\2\u0163\u0161\3\2\2\2\u0164")
        buf.write("\u0167\3\2\2\2\u0165\u0163\3\2\2\2\u0165\u0166\3\2\2\2")
        buf.write("\u0166]\3\2\2\2\u0167\u0165\3\2\2\2\u0168\u016d\5P)\2")
        buf.write("\u0169\u016a\7N\2\2\u016a\u016c\5P)\2\u016b\u0169\3\2")
        buf.write("\2\2\u016c\u016f\3\2\2\2\u016d\u016b\3\2\2\2\u016d\u016e")
        buf.write("\3\2\2\2\u016e_\3\2\2\2\u016f\u016d\3\2\2\2\u0170\u0175")
        buf.write("\5R*\2\u0171\u0172\7N\2\2\u0172\u0174\5R*\2\u0173\u0171")
        buf.write("\3\2\2\2\u0174\u0177\3\2\2\2\u0175\u0173\3\2\2\2\u0175")
        buf.write("\u0176\3\2\2\2\u0176a\3\2\2\2\u0177\u0175\3\2\2\2\26e")
        buf.write("ny\u0082\u008b\u0097\u00a3\u00ae\u00bb\u00d7\u00e7\u00f4")
        buf.write("\u010e\u0121\u0139\u014c\u0150\u0165\u016d\u0175")
        return buf.getvalue()


class CopperParser ( Parser ):

    grammarFileName = "Copper.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'model'", "'view'", "'dimension'", "'measure'", 
                     "'from'", "'join'", "'extends'", "'extension'", "'type'", 
                     "'expression'", "'primary_key'", "'value_format'", 
                     "'label'", "'description'", "'hidden'", "'tiers'", 
                     "'sql_latitude'", "'sql_longitude'", "'units'", "'relationship'", 
                     "'required'", "'optional'", "'string'", "'number'", 
                     "'date'", "'date_time'", "'yesno'", "'tier'", "'bin'", 
                     "'location'", "'zipcode'", "'distance'", "'duration'", 
                     "'time'", "'unquoted'", "'count'", "'sum'", "'average'", 
                     "'min'", "'max'", "'count_distinct'", "'median'", "'percentile'", 
                     "'left_outer'", "'inner'", "'full_outer'", "'cross'", 
                     "'one_to_one'", "'many_to_one'", "'one_to_many'", "'many_to_many'", 
                     "'usd'", "'eur'", "'gbp'", "'percent_1'", "'percent_2'", 
                     "'decimal_0'", "'decimal_1'", "'decimal_2'", "'id'", 
                     "'miles'", "'kilometers'", "'meters'", "'feet'", "'true'", 
                     "'false'", "'yes'", "'no'", "':'", "';'", "';;'", "'{'", 
                     "'}'", "'['", "']'", "','", "'('", "')'", "'.'", "'+'", 
                     "'-'", "'*'", "'/'", "'='", "'<'", "'>'" ]

    symbolicNames = [ "<INVALID>", "MODEL", "VIEW", "DIMENSION", "MEASURE", 
                      "FROM", "JOIN", "EXTENDS", "EXTENSION", "TYPE", "EXPRESSION", 
                      "PRIMARY_KEY", "VALUE_FORMAT", "LABEL", "DESCRIPTION", 
                      "HIDDEN_PARAM", "TIERS", "SQL_LATITUDE", "SQL_LONGITUDE", 
                      "UNITS", "RELATIONSHIP", "REQUIRED", "OPTIONAL", "STRING_TYPE", 
                      "NUMBER_TYPE", "DATE_TYPE", "DATE_TIME_TYPE", "YESNO_TYPE", 
                      "TIER_TYPE", "BIN_TYPE", "LOCATION_TYPE", "ZIPCODE_TYPE", 
                      "DISTANCE_TYPE", "DURATION_TYPE", "TIME_TYPE", "UNQUOTED_TYPE", 
                      "COUNT_TYPE", "SUM_TYPE", "AVERAGE_TYPE", "MIN_TYPE", 
                      "MAX_TYPE", "COUNT_DISTINCT_TYPE", "MEDIAN_TYPE", 
                      "PERCENTILE_TYPE", "LEFT_OUTER", "INNER", "FULL_OUTER", 
                      "CROSS", "ONE_TO_ONE", "MANY_TO_ONE", "ONE_TO_MANY", 
                      "MANY_TO_MANY", "USD", "EUR", "GBP", "PERCENT_1", 
                      "PERCENT_2", "DECIMAL_0", "DECIMAL_1", "DECIMAL_2", 
                      "ID", "MILES", "KILOMETERS", "METERS", "FEET", "TRUE", 
                      "FALSE", "YES", "NO", "COLON", "SEMICOLON", "SEMICOLON_SEMICOLON", 
                      "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "COMMA", 
                      "LPAREN", "RPAREN", "DOT", "PLUS", "MINUS", "MULTIPLY", 
                      "DIVIDE", "EQUALS", "LESS_THAN", "GREATER_THAN", "IDENTIFIER", 
                      "STRING_LITERAL", "NUMBER_LITERAL", "COMMENT", "NEWLINE", 
                      "WS", "HIDDEN" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_comment = 2
    RULE_modelStatement = 3
    RULE_modelBody = 4
    RULE_dimensionStatement = 5
    RULE_measureStatement = 6
    RULE_viewStatement = 7
    RULE_viewBody = 8
    RULE_fromStatement = 9
    RULE_joinStatement = 10
    RULE_extendsStatement = 11
    RULE_extensionStatement = 12
    RULE_dimensionParameter = 13
    RULE_typeParameter = 14
    RULE_dimensionType = 15
    RULE_measureParameter = 16
    RULE_measureTypeParameter = 17
    RULE_measureType = 18
    RULE_joinParameter = 19
    RULE_joinTypeParameter = 20
    RULE_joinType = 21
    RULE_relationshipParameter = 22
    RULE_relationshipType = 23
    RULE_expressionParameter = 24
    RULE_primaryKeyParameter = 25
    RULE_valueFormatParameter = 26
    RULE_labelParameter = 27
    RULE_descriptionParameter = 28
    RULE_hiddenParameter = 29
    RULE_tiersParameter = 30
    RULE_sqlLatitudeParameter = 31
    RULE_sqlLongitudeParameter = 32
    RULE_unitsParameter = 33
    RULE_daxExpression = 34
    RULE_daxContent = 35
    RULE_daxToken = 36
    RULE_identifier = 37
    RULE_contextualKeyword = 38
    RULE_stringLiteral = 39
    RULE_numberLiteral = 40
    RULE_booleanValue = 41
    RULE_booleanLiteral = 42
    RULE_formatName = 43
    RULE_units = 44
    RULE_identifierList = 45
    RULE_stringList = 46
    RULE_numberList = 47

    ruleNames =  [ "program", "statement", "comment", "modelStatement", 
                   "modelBody", "dimensionStatement", "measureStatement", 
                   "viewStatement", "viewBody", "fromStatement", "joinStatement", 
                   "extendsStatement", "extensionStatement", "dimensionParameter", 
                   "typeParameter", "dimensionType", "measureParameter", 
                   "measureTypeParameter", "measureType", "joinParameter", 
                   "joinTypeParameter", "joinType", "relationshipParameter", 
                   "relationshipType", "expressionParameter", "primaryKeyParameter", 
                   "valueFormatParameter", "labelParameter", "descriptionParameter", 
                   "hiddenParameter", "tiersParameter", "sqlLatitudeParameter", 
                   "sqlLongitudeParameter", "unitsParameter", "daxExpression", 
                   "daxContent", "daxToken", "identifier", "contextualKeyword", 
                   "stringLiteral", "numberLiteral", "booleanValue", "booleanLiteral", 
                   "formatName", "units", "identifierList", "stringList", 
                   "numberList" ]

    EOF = Token.EOF
    MODEL=1
    VIEW=2
    DIMENSION=3
    MEASURE=4
    FROM=5
    JOIN=6
    EXTENDS=7
    EXTENSION=8
    TYPE=9
    EXPRESSION=10
    PRIMARY_KEY=11
    VALUE_FORMAT=12
    LABEL=13
    DESCRIPTION=14
    HIDDEN_PARAM=15
    TIERS=16
    SQL_LATITUDE=17
    SQL_LONGITUDE=18
    UNITS=19
    RELATIONSHIP=20
    REQUIRED=21
    OPTIONAL=22
    STRING_TYPE=23
    NUMBER_TYPE=24
    DATE_TYPE=25
    DATE_TIME_TYPE=26
    YESNO_TYPE=27
    TIER_TYPE=28
    BIN_TYPE=29
    LOCATION_TYPE=30
    ZIPCODE_TYPE=31
    DISTANCE_TYPE=32
    DURATION_TYPE=33
    TIME_TYPE=34
    UNQUOTED_TYPE=35
    COUNT_TYPE=36
    SUM_TYPE=37
    AVERAGE_TYPE=38
    MIN_TYPE=39
    MAX_TYPE=40
    COUNT_DISTINCT_TYPE=41
    MEDIAN_TYPE=42
    PERCENTILE_TYPE=43
    LEFT_OUTER=44
    INNER=45
    FULL_OUTER=46
    CROSS=47
    ONE_TO_ONE=48
    MANY_TO_ONE=49
    ONE_TO_MANY=50
    MANY_TO_MANY=51
    USD=52
    EUR=53
    GBP=54
    PERCENT_1=55
    PERCENT_2=56
    DECIMAL_0=57
    DECIMAL_1=58
    DECIMAL_2=59
    ID=60
    MILES=61
    KILOMETERS=62
    METERS=63
    FEET=64
    TRUE=65
    FALSE=66
    YES=67
    NO=68
    COLON=69
    SEMICOLON=70
    SEMICOLON_SEMICOLON=71
    LBRACE=72
    RBRACE=73
    LBRACKET=74
    RBRACKET=75
    COMMA=76
    LPAREN=77
    RPAREN=78
    DOT=79
    PLUS=80
    MINUS=81
    MULTIPLY=82
    DIVIDE=83
    EQUALS=84
    LESS_THAN=85
    GREATER_THAN=86
    IDENTIFIER=87
    STRING_LITERAL=88
    NUMBER_LITERAL=89
    COMMENT=90
    NEWLINE=91
    WS=92
    HIDDEN=93

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(CopperParser.EOF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.StatementContext)
            else:
                return self.getTypedRuleContext(CopperParser.StatementContext,i)


        def getRuleIndex(self):
            return CopperParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = CopperParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CopperParser.MODEL or _la==CopperParser.VIEW or _la==CopperParser.COMMENT or _la==CopperParser.NEWLINE:
                self.state = 96
                self.statement()
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 102
            self.match(CopperParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modelStatement(self):
            return self.getTypedRuleContext(CopperParser.ModelStatementContext,0)


        def viewStatement(self):
            return self.getTypedRuleContext(CopperParser.ViewStatementContext,0)


        def comment(self):
            return self.getTypedRuleContext(CopperParser.CommentContext,0)


        def NEWLINE(self):
            return self.getToken(CopperParser.NEWLINE, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = CopperParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 108
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.MODEL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 104
                self.modelStatement()
                pass
            elif token in [CopperParser.VIEW]:
                self.enterOuterAlt(localctx, 2)
                self.state = 105
                self.viewStatement()
                pass
            elif token in [CopperParser.COMMENT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 106
                self.comment()
                pass
            elif token in [CopperParser.NEWLINE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 107
                self.match(CopperParser.NEWLINE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(CopperParser.COMMENT, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_comment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment" ):
                listener.enterComment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment" ):
                listener.exitComment(self)




    def comment(self):

        localctx = CopperParser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_comment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 110
            self.match(CopperParser.COMMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModelStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODEL(self):
            return self.getToken(CopperParser.MODEL, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def identifier(self):
            return self.getTypedRuleContext(CopperParser.IdentifierContext,0)


        def LBRACE(self):
            return self.getToken(CopperParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(CopperParser.RBRACE, 0)

        def modelBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.ModelBodyContext)
            else:
                return self.getTypedRuleContext(CopperParser.ModelBodyContext,i)


        def getRuleIndex(self):
            return CopperParser.RULE_modelStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModelStatement" ):
                listener.enterModelStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModelStatement" ):
                listener.exitModelStatement(self)




    def modelStatement(self):

        localctx = CopperParser.ModelStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_modelStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.match(CopperParser.MODEL)
            self.state = 113
            self.match(CopperParser.COLON)
            self.state = 114
            self.identifier()
            self.state = 115
            self.match(CopperParser.LBRACE)
            self.state = 119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CopperParser.DIMENSION or _la==CopperParser.MEASURE or _la==CopperParser.COMMENT or _la==CopperParser.NEWLINE:
                self.state = 116
                self.modelBody()
                self.state = 121
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 122
            self.match(CopperParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModelBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dimensionStatement(self):
            return self.getTypedRuleContext(CopperParser.DimensionStatementContext,0)


        def measureStatement(self):
            return self.getTypedRuleContext(CopperParser.MeasureStatementContext,0)


        def comment(self):
            return self.getTypedRuleContext(CopperParser.CommentContext,0)


        def NEWLINE(self):
            return self.getToken(CopperParser.NEWLINE, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_modelBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModelBody" ):
                listener.enterModelBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModelBody" ):
                listener.exitModelBody(self)




    def modelBody(self):

        localctx = CopperParser.ModelBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_modelBody)
        try:
            self.state = 128
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.DIMENSION]:
                self.enterOuterAlt(localctx, 1)
                self.state = 124
                self.dimensionStatement()
                pass
            elif token in [CopperParser.MEASURE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 125
                self.measureStatement()
                pass
            elif token in [CopperParser.COMMENT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 126
                self.comment()
                pass
            elif token in [CopperParser.NEWLINE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 127
                self.match(CopperParser.NEWLINE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DimensionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIMENSION(self):
            return self.getToken(CopperParser.DIMENSION, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def identifier(self):
            return self.getTypedRuleContext(CopperParser.IdentifierContext,0)


        def LBRACE(self):
            return self.getToken(CopperParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(CopperParser.RBRACE, 0)

        def dimensionParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.DimensionParameterContext)
            else:
                return self.getTypedRuleContext(CopperParser.DimensionParameterContext,i)


        def getRuleIndex(self):
            return CopperParser.RULE_dimensionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensionStatement" ):
                listener.enterDimensionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensionStatement" ):
                listener.exitDimensionStatement(self)




    def dimensionStatement(self):

        localctx = CopperParser.DimensionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_dimensionStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            self.match(CopperParser.DIMENSION)
            self.state = 131
            self.match(CopperParser.COLON)
            self.state = 132
            self.identifier()
            self.state = 133
            self.match(CopperParser.LBRACE)
            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.TYPE) | (1 << CopperParser.EXPRESSION) | (1 << CopperParser.PRIMARY_KEY) | (1 << CopperParser.VALUE_FORMAT) | (1 << CopperParser.LABEL) | (1 << CopperParser.DESCRIPTION) | (1 << CopperParser.TIERS) | (1 << CopperParser.SQL_LATITUDE) | (1 << CopperParser.SQL_LONGITUDE) | (1 << CopperParser.UNITS))) != 0) or ((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & ((1 << (CopperParser.COMMENT - 90)) | (1 << (CopperParser.NEWLINE - 90)) | (1 << (CopperParser.HIDDEN - 90)))) != 0):
                self.state = 134
                self.dimensionParameter()
                self.state = 139
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 140
            self.match(CopperParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MeasureStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MEASURE(self):
            return self.getToken(CopperParser.MEASURE, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def identifier(self):
            return self.getTypedRuleContext(CopperParser.IdentifierContext,0)


        def LBRACE(self):
            return self.getToken(CopperParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(CopperParser.RBRACE, 0)

        def measureParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.MeasureParameterContext)
            else:
                return self.getTypedRuleContext(CopperParser.MeasureParameterContext,i)


        def getRuleIndex(self):
            return CopperParser.RULE_measureStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasureStatement" ):
                listener.enterMeasureStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasureStatement" ):
                listener.exitMeasureStatement(self)




    def measureStatement(self):

        localctx = CopperParser.MeasureStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_measureStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(CopperParser.MEASURE)
            self.state = 143
            self.match(CopperParser.COLON)
            self.state = 144
            self.identifier()
            self.state = 145
            self.match(CopperParser.LBRACE)
            self.state = 149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.TYPE) | (1 << CopperParser.EXPRESSION) | (1 << CopperParser.VALUE_FORMAT) | (1 << CopperParser.LABEL) | (1 << CopperParser.DESCRIPTION))) != 0) or ((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & ((1 << (CopperParser.COMMENT - 90)) | (1 << (CopperParser.NEWLINE - 90)) | (1 << (CopperParser.HIDDEN - 90)))) != 0):
                self.state = 146
                self.measureParameter()
                self.state = 151
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 152
            self.match(CopperParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ViewStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VIEW(self):
            return self.getToken(CopperParser.VIEW, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def identifier(self):
            return self.getTypedRuleContext(CopperParser.IdentifierContext,0)


        def LBRACE(self):
            return self.getToken(CopperParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(CopperParser.RBRACE, 0)

        def viewBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.ViewBodyContext)
            else:
                return self.getTypedRuleContext(CopperParser.ViewBodyContext,i)


        def getRuleIndex(self):
            return CopperParser.RULE_viewStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewStatement" ):
                listener.enterViewStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewStatement" ):
                listener.exitViewStatement(self)




    def viewStatement(self):

        localctx = CopperParser.ViewStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_viewStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(CopperParser.VIEW)
            self.state = 155
            self.match(CopperParser.COLON)
            self.state = 156
            self.identifier()
            self.state = 157
            self.match(CopperParser.LBRACE)
            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.FROM) | (1 << CopperParser.JOIN) | (1 << CopperParser.EXTENDS) | (1 << CopperParser.EXTENSION))) != 0) or _la==CopperParser.COMMENT or _la==CopperParser.NEWLINE:
                self.state = 158
                self.viewBody()
                self.state = 163
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 164
            self.match(CopperParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ViewBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fromStatement(self):
            return self.getTypedRuleContext(CopperParser.FromStatementContext,0)


        def joinStatement(self):
            return self.getTypedRuleContext(CopperParser.JoinStatementContext,0)


        def extendsStatement(self):
            return self.getTypedRuleContext(CopperParser.ExtendsStatementContext,0)


        def extensionStatement(self):
            return self.getTypedRuleContext(CopperParser.ExtensionStatementContext,0)


        def comment(self):
            return self.getTypedRuleContext(CopperParser.CommentContext,0)


        def NEWLINE(self):
            return self.getToken(CopperParser.NEWLINE, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_viewBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViewBody" ):
                listener.enterViewBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViewBody" ):
                listener.exitViewBody(self)




    def viewBody(self):

        localctx = CopperParser.ViewBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_viewBody)
        try:
            self.state = 172
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.FROM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 166
                self.fromStatement()
                pass
            elif token in [CopperParser.JOIN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 167
                self.joinStatement()
                pass
            elif token in [CopperParser.EXTENDS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 168
                self.extendsStatement()
                pass
            elif token in [CopperParser.EXTENSION]:
                self.enterOuterAlt(localctx, 4)
                self.state = 169
                self.extensionStatement()
                pass
            elif token in [CopperParser.COMMENT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 170
                self.comment()
                pass
            elif token in [CopperParser.NEWLINE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 171
                self.match(CopperParser.NEWLINE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FromStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(CopperParser.FROM, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def identifier(self):
            return self.getTypedRuleContext(CopperParser.IdentifierContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_fromStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromStatement" ):
                listener.enterFromStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromStatement" ):
                listener.exitFromStatement(self)




    def fromStatement(self):

        localctx = CopperParser.FromStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_fromStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(CopperParser.FROM)
            self.state = 175
            self.match(CopperParser.COLON)
            self.state = 176
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JOIN(self):
            return self.getToken(CopperParser.JOIN, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def identifier(self):
            return self.getTypedRuleContext(CopperParser.IdentifierContext,0)


        def LBRACE(self):
            return self.getToken(CopperParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(CopperParser.RBRACE, 0)

        def joinParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.JoinParameterContext)
            else:
                return self.getTypedRuleContext(CopperParser.JoinParameterContext,i)


        def getRuleIndex(self):
            return CopperParser.RULE_joinStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinStatement" ):
                listener.enterJoinStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinStatement" ):
                listener.exitJoinStatement(self)




    def joinStatement(self):

        localctx = CopperParser.JoinStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_joinStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(CopperParser.JOIN)
            self.state = 179
            self.match(CopperParser.COLON)
            self.state = 180
            self.identifier()
            self.state = 181
            self.match(CopperParser.LBRACE)
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.TYPE) | (1 << CopperParser.EXPRESSION) | (1 << CopperParser.RELATIONSHIP))) != 0) or _la==CopperParser.COMMENT or _la==CopperParser.NEWLINE:
                self.state = 182
                self.joinParameter()
                self.state = 187
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 188
            self.match(CopperParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExtendsStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENDS(self):
            return self.getToken(CopperParser.EXTENDS, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def LBRACKET(self):
            return self.getToken(CopperParser.LBRACKET, 0)

        def identifierList(self):
            return self.getTypedRuleContext(CopperParser.IdentifierListContext,0)


        def RBRACKET(self):
            return self.getToken(CopperParser.RBRACKET, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_extendsStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtendsStatement" ):
                listener.enterExtendsStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtendsStatement" ):
                listener.exitExtendsStatement(self)




    def extendsStatement(self):

        localctx = CopperParser.ExtendsStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_extendsStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(CopperParser.EXTENDS)
            self.state = 191
            self.match(CopperParser.COLON)
            self.state = 192
            self.match(CopperParser.LBRACKET)
            self.state = 193
            self.identifierList()
            self.state = 194
            self.match(CopperParser.RBRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExtensionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENSION(self):
            return self.getToken(CopperParser.EXTENSION, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def REQUIRED(self):
            return self.getToken(CopperParser.REQUIRED, 0)

        def OPTIONAL(self):
            return self.getToken(CopperParser.OPTIONAL, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_extensionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtensionStatement" ):
                listener.enterExtensionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtensionStatement" ):
                listener.exitExtensionStatement(self)




    def extensionStatement(self):

        localctx = CopperParser.ExtensionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_extensionStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(CopperParser.EXTENSION)
            self.state = 197
            self.match(CopperParser.COLON)
            self.state = 198
            _la = self._input.LA(1)
            if not(_la==CopperParser.REQUIRED or _la==CopperParser.OPTIONAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DimensionParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeParameter(self):
            return self.getTypedRuleContext(CopperParser.TypeParameterContext,0)


        def expressionParameter(self):
            return self.getTypedRuleContext(CopperParser.ExpressionParameterContext,0)


        def primaryKeyParameter(self):
            return self.getTypedRuleContext(CopperParser.PrimaryKeyParameterContext,0)


        def valueFormatParameter(self):
            return self.getTypedRuleContext(CopperParser.ValueFormatParameterContext,0)


        def labelParameter(self):
            return self.getTypedRuleContext(CopperParser.LabelParameterContext,0)


        def descriptionParameter(self):
            return self.getTypedRuleContext(CopperParser.DescriptionParameterContext,0)


        def hiddenParameter(self):
            return self.getTypedRuleContext(CopperParser.HiddenParameterContext,0)


        def tiersParameter(self):
            return self.getTypedRuleContext(CopperParser.TiersParameterContext,0)


        def sqlLatitudeParameter(self):
            return self.getTypedRuleContext(CopperParser.SqlLatitudeParameterContext,0)


        def sqlLongitudeParameter(self):
            return self.getTypedRuleContext(CopperParser.SqlLongitudeParameterContext,0)


        def unitsParameter(self):
            return self.getTypedRuleContext(CopperParser.UnitsParameterContext,0)


        def comment(self):
            return self.getTypedRuleContext(CopperParser.CommentContext,0)


        def NEWLINE(self):
            return self.getToken(CopperParser.NEWLINE, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_dimensionParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensionParameter" ):
                listener.enterDimensionParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensionParameter" ):
                listener.exitDimensionParameter(self)




    def dimensionParameter(self):

        localctx = CopperParser.DimensionParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_dimensionParameter)
        try:
            self.state = 213
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.TYPE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 200
                self.typeParameter()
                pass
            elif token in [CopperParser.EXPRESSION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 201
                self.expressionParameter()
                pass
            elif token in [CopperParser.PRIMARY_KEY]:
                self.enterOuterAlt(localctx, 3)
                self.state = 202
                self.primaryKeyParameter()
                pass
            elif token in [CopperParser.VALUE_FORMAT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 203
                self.valueFormatParameter()
                pass
            elif token in [CopperParser.LABEL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 204
                self.labelParameter()
                pass
            elif token in [CopperParser.DESCRIPTION]:
                self.enterOuterAlt(localctx, 6)
                self.state = 205
                self.descriptionParameter()
                pass
            elif token in [CopperParser.HIDDEN]:
                self.enterOuterAlt(localctx, 7)
                self.state = 206
                self.hiddenParameter()
                pass
            elif token in [CopperParser.TIERS]:
                self.enterOuterAlt(localctx, 8)
                self.state = 207
                self.tiersParameter()
                pass
            elif token in [CopperParser.SQL_LATITUDE]:
                self.enterOuterAlt(localctx, 9)
                self.state = 208
                self.sqlLatitudeParameter()
                pass
            elif token in [CopperParser.SQL_LONGITUDE]:
                self.enterOuterAlt(localctx, 10)
                self.state = 209
                self.sqlLongitudeParameter()
                pass
            elif token in [CopperParser.UNITS]:
                self.enterOuterAlt(localctx, 11)
                self.state = 210
                self.unitsParameter()
                pass
            elif token in [CopperParser.COMMENT]:
                self.enterOuterAlt(localctx, 12)
                self.state = 211
                self.comment()
                pass
            elif token in [CopperParser.NEWLINE]:
                self.enterOuterAlt(localctx, 13)
                self.state = 212
                self.match(CopperParser.NEWLINE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(CopperParser.TYPE, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def dimensionType(self):
            return self.getTypedRuleContext(CopperParser.DimensionTypeContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_typeParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeParameter" ):
                listener.enterTypeParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeParameter" ):
                listener.exitTypeParameter(self)




    def typeParameter(self):

        localctx = CopperParser.TypeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_typeParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            self.match(CopperParser.TYPE)
            self.state = 216
            self.match(CopperParser.COLON)
            self.state = 217
            self.dimensionType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DimensionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_TYPE(self):
            return self.getToken(CopperParser.STRING_TYPE, 0)

        def NUMBER_TYPE(self):
            return self.getToken(CopperParser.NUMBER_TYPE, 0)

        def DATE_TYPE(self):
            return self.getToken(CopperParser.DATE_TYPE, 0)

        def DATE_TIME_TYPE(self):
            return self.getToken(CopperParser.DATE_TIME_TYPE, 0)

        def YESNO_TYPE(self):
            return self.getToken(CopperParser.YESNO_TYPE, 0)

        def TIER_TYPE(self):
            return self.getToken(CopperParser.TIER_TYPE, 0)

        def BIN_TYPE(self):
            return self.getToken(CopperParser.BIN_TYPE, 0)

        def LOCATION_TYPE(self):
            return self.getToken(CopperParser.LOCATION_TYPE, 0)

        def ZIPCODE_TYPE(self):
            return self.getToken(CopperParser.ZIPCODE_TYPE, 0)

        def DISTANCE_TYPE(self):
            return self.getToken(CopperParser.DISTANCE_TYPE, 0)

        def DURATION_TYPE(self):
            return self.getToken(CopperParser.DURATION_TYPE, 0)

        def TIME_TYPE(self):
            return self.getToken(CopperParser.TIME_TYPE, 0)

        def UNQUOTED_TYPE(self):
            return self.getToken(CopperParser.UNQUOTED_TYPE, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_dimensionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensionType" ):
                listener.enterDimensionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensionType" ):
                listener.exitDimensionType(self)




    def dimensionType(self):

        localctx = CopperParser.DimensionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_dimensionType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.STRING_TYPE) | (1 << CopperParser.NUMBER_TYPE) | (1 << CopperParser.DATE_TYPE) | (1 << CopperParser.DATE_TIME_TYPE) | (1 << CopperParser.YESNO_TYPE) | (1 << CopperParser.TIER_TYPE) | (1 << CopperParser.BIN_TYPE) | (1 << CopperParser.LOCATION_TYPE) | (1 << CopperParser.ZIPCODE_TYPE) | (1 << CopperParser.DISTANCE_TYPE) | (1 << CopperParser.DURATION_TYPE) | (1 << CopperParser.TIME_TYPE) | (1 << CopperParser.UNQUOTED_TYPE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MeasureParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def measureTypeParameter(self):
            return self.getTypedRuleContext(CopperParser.MeasureTypeParameterContext,0)


        def expressionParameter(self):
            return self.getTypedRuleContext(CopperParser.ExpressionParameterContext,0)


        def valueFormatParameter(self):
            return self.getTypedRuleContext(CopperParser.ValueFormatParameterContext,0)


        def labelParameter(self):
            return self.getTypedRuleContext(CopperParser.LabelParameterContext,0)


        def descriptionParameter(self):
            return self.getTypedRuleContext(CopperParser.DescriptionParameterContext,0)


        def hiddenParameter(self):
            return self.getTypedRuleContext(CopperParser.HiddenParameterContext,0)


        def comment(self):
            return self.getTypedRuleContext(CopperParser.CommentContext,0)


        def NEWLINE(self):
            return self.getToken(CopperParser.NEWLINE, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_measureParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasureParameter" ):
                listener.enterMeasureParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasureParameter" ):
                listener.exitMeasureParameter(self)




    def measureParameter(self):

        localctx = CopperParser.MeasureParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_measureParameter)
        try:
            self.state = 229
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.TYPE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 221
                self.measureTypeParameter()
                pass
            elif token in [CopperParser.EXPRESSION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 222
                self.expressionParameter()
                pass
            elif token in [CopperParser.VALUE_FORMAT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 223
                self.valueFormatParameter()
                pass
            elif token in [CopperParser.LABEL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 224
                self.labelParameter()
                pass
            elif token in [CopperParser.DESCRIPTION]:
                self.enterOuterAlt(localctx, 5)
                self.state = 225
                self.descriptionParameter()
                pass
            elif token in [CopperParser.HIDDEN]:
                self.enterOuterAlt(localctx, 6)
                self.state = 226
                self.hiddenParameter()
                pass
            elif token in [CopperParser.COMMENT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 227
                self.comment()
                pass
            elif token in [CopperParser.NEWLINE]:
                self.enterOuterAlt(localctx, 8)
                self.state = 228
                self.match(CopperParser.NEWLINE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MeasureTypeParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(CopperParser.TYPE, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def measureType(self):
            return self.getTypedRuleContext(CopperParser.MeasureTypeContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_measureTypeParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasureTypeParameter" ):
                listener.enterMeasureTypeParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasureTypeParameter" ):
                listener.exitMeasureTypeParameter(self)




    def measureTypeParameter(self):

        localctx = CopperParser.MeasureTypeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_measureTypeParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(CopperParser.TYPE)
            self.state = 232
            self.match(CopperParser.COLON)
            self.state = 233
            self.measureType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MeasureTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT_TYPE(self):
            return self.getToken(CopperParser.COUNT_TYPE, 0)

        def SUM_TYPE(self):
            return self.getToken(CopperParser.SUM_TYPE, 0)

        def AVERAGE_TYPE(self):
            return self.getToken(CopperParser.AVERAGE_TYPE, 0)

        def MIN_TYPE(self):
            return self.getToken(CopperParser.MIN_TYPE, 0)

        def MAX_TYPE(self):
            return self.getToken(CopperParser.MAX_TYPE, 0)

        def COUNT_DISTINCT_TYPE(self):
            return self.getToken(CopperParser.COUNT_DISTINCT_TYPE, 0)

        def MEDIAN_TYPE(self):
            return self.getToken(CopperParser.MEDIAN_TYPE, 0)

        def PERCENTILE_TYPE(self):
            return self.getToken(CopperParser.PERCENTILE_TYPE, 0)

        def NUMBER_TYPE(self):
            return self.getToken(CopperParser.NUMBER_TYPE, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_measureType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasureType" ):
                listener.enterMeasureType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasureType" ):
                listener.exitMeasureType(self)




    def measureType(self):

        localctx = CopperParser.MeasureTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_measureType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.NUMBER_TYPE) | (1 << CopperParser.COUNT_TYPE) | (1 << CopperParser.SUM_TYPE) | (1 << CopperParser.AVERAGE_TYPE) | (1 << CopperParser.MIN_TYPE) | (1 << CopperParser.MAX_TYPE) | (1 << CopperParser.COUNT_DISTINCT_TYPE) | (1 << CopperParser.MEDIAN_TYPE) | (1 << CopperParser.PERCENTILE_TYPE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def joinTypeParameter(self):
            return self.getTypedRuleContext(CopperParser.JoinTypeParameterContext,0)


        def relationshipParameter(self):
            return self.getTypedRuleContext(CopperParser.RelationshipParameterContext,0)


        def expressionParameter(self):
            return self.getTypedRuleContext(CopperParser.ExpressionParameterContext,0)


        def comment(self):
            return self.getTypedRuleContext(CopperParser.CommentContext,0)


        def NEWLINE(self):
            return self.getToken(CopperParser.NEWLINE, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_joinParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinParameter" ):
                listener.enterJoinParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinParameter" ):
                listener.exitJoinParameter(self)




    def joinParameter(self):

        localctx = CopperParser.JoinParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_joinParameter)
        try:
            self.state = 242
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.TYPE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 237
                self.joinTypeParameter()
                pass
            elif token in [CopperParser.RELATIONSHIP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 238
                self.relationshipParameter()
                pass
            elif token in [CopperParser.EXPRESSION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 239
                self.expressionParameter()
                pass
            elif token in [CopperParser.COMMENT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 240
                self.comment()
                pass
            elif token in [CopperParser.NEWLINE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 241
                self.match(CopperParser.NEWLINE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinTypeParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(CopperParser.TYPE, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def joinType(self):
            return self.getTypedRuleContext(CopperParser.JoinTypeContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_joinTypeParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinTypeParameter" ):
                listener.enterJoinTypeParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinTypeParameter" ):
                listener.exitJoinTypeParameter(self)




    def joinTypeParameter(self):

        localctx = CopperParser.JoinTypeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_joinTypeParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self.match(CopperParser.TYPE)
            self.state = 245
            self.match(CopperParser.COLON)
            self.state = 246
            self.joinType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_OUTER(self):
            return self.getToken(CopperParser.LEFT_OUTER, 0)

        def INNER(self):
            return self.getToken(CopperParser.INNER, 0)

        def FULL_OUTER(self):
            return self.getToken(CopperParser.FULL_OUTER, 0)

        def CROSS(self):
            return self.getToken(CopperParser.CROSS, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_joinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinType" ):
                listener.enterJoinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinType" ):
                listener.exitJoinType(self)




    def joinType(self):

        localctx = CopperParser.JoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_joinType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.LEFT_OUTER) | (1 << CopperParser.INNER) | (1 << CopperParser.FULL_OUTER) | (1 << CopperParser.CROSS))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RELATIONSHIP(self):
            return self.getToken(CopperParser.RELATIONSHIP, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def relationshipType(self):
            return self.getTypedRuleContext(CopperParser.RelationshipTypeContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_relationshipParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipParameter" ):
                listener.enterRelationshipParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipParameter" ):
                listener.exitRelationshipParameter(self)




    def relationshipParameter(self):

        localctx = CopperParser.RelationshipParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_relationshipParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(CopperParser.RELATIONSHIP)
            self.state = 251
            self.match(CopperParser.COLON)
            self.state = 252
            self.relationshipType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONE_TO_ONE(self):
            return self.getToken(CopperParser.ONE_TO_ONE, 0)

        def MANY_TO_ONE(self):
            return self.getToken(CopperParser.MANY_TO_ONE, 0)

        def ONE_TO_MANY(self):
            return self.getToken(CopperParser.ONE_TO_MANY, 0)

        def MANY_TO_MANY(self):
            return self.getToken(CopperParser.MANY_TO_MANY, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_relationshipType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipType" ):
                listener.enterRelationshipType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipType" ):
                listener.exitRelationshipType(self)




    def relationshipType(self):

        localctx = CopperParser.RelationshipTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_relationshipType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.ONE_TO_ONE) | (1 << CopperParser.MANY_TO_ONE) | (1 << CopperParser.ONE_TO_MANY) | (1 << CopperParser.MANY_TO_MANY))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXPRESSION(self):
            return self.getToken(CopperParser.EXPRESSION, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def daxExpression(self):
            return self.getTypedRuleContext(CopperParser.DaxExpressionContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_expressionParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionParameter" ):
                listener.enterExpressionParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionParameter" ):
                listener.exitExpressionParameter(self)




    def expressionParameter(self):

        localctx = CopperParser.ExpressionParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_expressionParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.match(CopperParser.EXPRESSION)
            self.state = 257
            self.match(CopperParser.COLON)
            self.state = 258
            self.daxExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimaryKeyParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRIMARY_KEY(self):
            return self.getToken(CopperParser.PRIMARY_KEY, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def booleanValue(self):
            return self.getTypedRuleContext(CopperParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_primaryKeyParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryKeyParameter" ):
                listener.enterPrimaryKeyParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryKeyParameter" ):
                listener.exitPrimaryKeyParameter(self)




    def primaryKeyParameter(self):

        localctx = CopperParser.PrimaryKeyParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_primaryKeyParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.match(CopperParser.PRIMARY_KEY)
            self.state = 261
            self.match(CopperParser.COLON)
            self.state = 262
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValueFormatParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALUE_FORMAT(self):
            return self.getToken(CopperParser.VALUE_FORMAT, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(CopperParser.StringLiteralContext,0)


        def formatName(self):
            return self.getTypedRuleContext(CopperParser.FormatNameContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_valueFormatParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValueFormatParameter" ):
                listener.enterValueFormatParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValueFormatParameter" ):
                listener.exitValueFormatParameter(self)




    def valueFormatParameter(self):

        localctx = CopperParser.ValueFormatParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_valueFormatParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(CopperParser.VALUE_FORMAT)
            self.state = 265
            self.match(CopperParser.COLON)
            self.state = 268
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.STRING_LITERAL]:
                self.state = 266
                self.stringLiteral()
                pass
            elif token in [CopperParser.USD, CopperParser.EUR, CopperParser.GBP, CopperParser.PERCENT_1, CopperParser.PERCENT_2, CopperParser.DECIMAL_0, CopperParser.DECIMAL_1, CopperParser.DECIMAL_2, CopperParser.ID]:
                self.state = 267
                self.formatName()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LabelParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(CopperParser.LABEL, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(CopperParser.StringLiteralContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_labelParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelParameter" ):
                listener.enterLabelParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelParameter" ):
                listener.exitLabelParameter(self)




    def labelParameter(self):

        localctx = CopperParser.LabelParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_labelParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            self.match(CopperParser.LABEL)
            self.state = 271
            self.match(CopperParser.COLON)
            self.state = 272
            self.stringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DescriptionParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DESCRIPTION(self):
            return self.getToken(CopperParser.DESCRIPTION, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(CopperParser.StringLiteralContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_descriptionParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDescriptionParameter" ):
                listener.enterDescriptionParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDescriptionParameter" ):
                listener.exitDescriptionParameter(self)




    def descriptionParameter(self):

        localctx = CopperParser.DescriptionParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_descriptionParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(CopperParser.DESCRIPTION)
            self.state = 275
            self.match(CopperParser.COLON)
            self.state = 276
            self.stringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HiddenParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HIDDEN(self):
            return self.getToken(CopperParser.HIDDEN, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def booleanValue(self):
            return self.getTypedRuleContext(CopperParser.BooleanValueContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_hiddenParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHiddenParameter" ):
                listener.enterHiddenParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHiddenParameter" ):
                listener.exitHiddenParameter(self)




    def hiddenParameter(self):

        localctx = CopperParser.HiddenParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_hiddenParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.match(CopperParser.HIDDEN)
            self.state = 279
            self.match(CopperParser.COLON)
            self.state = 280
            self.booleanValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TiersParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIERS(self):
            return self.getToken(CopperParser.TIERS, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def LBRACKET(self):
            return self.getToken(CopperParser.LBRACKET, 0)

        def RBRACKET(self):
            return self.getToken(CopperParser.RBRACKET, 0)

        def stringList(self):
            return self.getTypedRuleContext(CopperParser.StringListContext,0)


        def numberList(self):
            return self.getTypedRuleContext(CopperParser.NumberListContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_tiersParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTiersParameter" ):
                listener.enterTiersParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTiersParameter" ):
                listener.exitTiersParameter(self)




    def tiersParameter(self):

        localctx = CopperParser.TiersParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_tiersParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(CopperParser.TIERS)
            self.state = 283
            self.match(CopperParser.COLON)
            self.state = 284
            self.match(CopperParser.LBRACKET)
            self.state = 287
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.STRING_LITERAL]:
                self.state = 285
                self.stringList()
                pass
            elif token in [CopperParser.NUMBER_LITERAL]:
                self.state = 286
                self.numberList()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 289
            self.match(CopperParser.RBRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SqlLatitudeParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SQL_LATITUDE(self):
            return self.getToken(CopperParser.SQL_LATITUDE, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def daxExpression(self):
            return self.getTypedRuleContext(CopperParser.DaxExpressionContext,0)


        def SEMICOLON_SEMICOLON(self):
            return self.getToken(CopperParser.SEMICOLON_SEMICOLON, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_sqlLatitudeParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSqlLatitudeParameter" ):
                listener.enterSqlLatitudeParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSqlLatitudeParameter" ):
                listener.exitSqlLatitudeParameter(self)




    def sqlLatitudeParameter(self):

        localctx = CopperParser.SqlLatitudeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_sqlLatitudeParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self.match(CopperParser.SQL_LATITUDE)
            self.state = 292
            self.match(CopperParser.COLON)
            self.state = 293
            self.daxExpression()
            self.state = 294
            self.match(CopperParser.SEMICOLON_SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SqlLongitudeParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SQL_LONGITUDE(self):
            return self.getToken(CopperParser.SQL_LONGITUDE, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def daxExpression(self):
            return self.getTypedRuleContext(CopperParser.DaxExpressionContext,0)


        def SEMICOLON_SEMICOLON(self):
            return self.getToken(CopperParser.SEMICOLON_SEMICOLON, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_sqlLongitudeParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSqlLongitudeParameter" ):
                listener.enterSqlLongitudeParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSqlLongitudeParameter" ):
                listener.exitSqlLongitudeParameter(self)




    def sqlLongitudeParameter(self):

        localctx = CopperParser.SqlLongitudeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_sqlLongitudeParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.match(CopperParser.SQL_LONGITUDE)
            self.state = 297
            self.match(CopperParser.COLON)
            self.state = 298
            self.daxExpression()
            self.state = 299
            self.match(CopperParser.SEMICOLON_SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnitsParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNITS(self):
            return self.getToken(CopperParser.UNITS, 0)

        def COLON(self):
            return self.getToken(CopperParser.COLON, 0)

        def units(self):
            return self.getTypedRuleContext(CopperParser.UnitsContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_unitsParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitsParameter" ):
                listener.enterUnitsParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitsParameter" ):
                listener.exitUnitsParameter(self)




    def unitsParameter(self):

        localctx = CopperParser.UnitsParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_unitsParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self.match(CopperParser.UNITS)
            self.state = 302
            self.match(CopperParser.COLON)
            self.state = 303
            self.units()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DaxExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def daxContent(self):
            return self.getTypedRuleContext(CopperParser.DaxContentContext,0)


        def SEMICOLON_SEMICOLON(self):
            return self.getToken(CopperParser.SEMICOLON_SEMICOLON, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_daxExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDaxExpression" ):
                listener.enterDaxExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDaxExpression" ):
                listener.exitDaxExpression(self)




    def daxExpression(self):

        localctx = CopperParser.DaxExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_daxExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.daxContent()
            self.state = 306
            self.match(CopperParser.SEMICOLON_SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DaxContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def daxToken(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.DaxTokenContext)
            else:
                return self.getTypedRuleContext(CopperParser.DaxTokenContext,i)


        def getRuleIndex(self):
            return CopperParser.RULE_daxContent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDaxContent" ):
                listener.enterDaxContent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDaxContent" ):
                listener.exitDaxContent(self)




    def daxContent(self):

        localctx = CopperParser.DaxContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_daxContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 308
                self.daxToken()
                self.state = 311 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.STRING_TYPE) | (1 << CopperParser.NUMBER_TYPE) | (1 << CopperParser.DATE_TYPE) | (1 << CopperParser.DATE_TIME_TYPE) | (1 << CopperParser.YESNO_TYPE) | (1 << CopperParser.TIER_TYPE) | (1 << CopperParser.BIN_TYPE) | (1 << CopperParser.LOCATION_TYPE) | (1 << CopperParser.ZIPCODE_TYPE) | (1 << CopperParser.DISTANCE_TYPE) | (1 << CopperParser.DURATION_TYPE) | (1 << CopperParser.TIME_TYPE) | (1 << CopperParser.UNQUOTED_TYPE) | (1 << CopperParser.COUNT_TYPE) | (1 << CopperParser.SUM_TYPE) | (1 << CopperParser.AVERAGE_TYPE) | (1 << CopperParser.MIN_TYPE) | (1 << CopperParser.MAX_TYPE) | (1 << CopperParser.COUNT_DISTINCT_TYPE) | (1 << CopperParser.MEDIAN_TYPE) | (1 << CopperParser.PERCENTILE_TYPE) | (1 << CopperParser.LEFT_OUTER) | (1 << CopperParser.INNER) | (1 << CopperParser.FULL_OUTER) | (1 << CopperParser.CROSS) | (1 << CopperParser.ONE_TO_ONE) | (1 << CopperParser.MANY_TO_ONE) | (1 << CopperParser.ONE_TO_MANY) | (1 << CopperParser.MANY_TO_MANY) | (1 << CopperParser.USD) | (1 << CopperParser.EUR) | (1 << CopperParser.GBP) | (1 << CopperParser.PERCENT_1) | (1 << CopperParser.PERCENT_2) | (1 << CopperParser.DECIMAL_0) | (1 << CopperParser.DECIMAL_1) | (1 << CopperParser.DECIMAL_2) | (1 << CopperParser.ID) | (1 << CopperParser.MILES) | (1 << CopperParser.KILOMETERS) | (1 << CopperParser.METERS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CopperParser.FEET - 64)) | (1 << (CopperParser.LBRACKET - 64)) | (1 << (CopperParser.RBRACKET - 64)) | (1 << (CopperParser.COMMA - 64)) | (1 << (CopperParser.LPAREN - 64)) | (1 << (CopperParser.RPAREN - 64)) | (1 << (CopperParser.DOT - 64)) | (1 << (CopperParser.PLUS - 64)) | (1 << (CopperParser.MINUS - 64)) | (1 << (CopperParser.MULTIPLY - 64)) | (1 << (CopperParser.DIVIDE - 64)) | (1 << (CopperParser.EQUALS - 64)) | (1 << (CopperParser.LESS_THAN - 64)) | (1 << (CopperParser.GREATER_THAN - 64)) | (1 << (CopperParser.IDENTIFIER - 64)) | (1 << (CopperParser.STRING_LITERAL - 64)) | (1 << (CopperParser.NUMBER_LITERAL - 64)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DaxTokenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CopperParser.IDENTIFIER, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(CopperParser.NUMBER_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(CopperParser.STRING_LITERAL, 0)

        def LBRACKET(self):
            return self.getToken(CopperParser.LBRACKET, 0)

        def RBRACKET(self):
            return self.getToken(CopperParser.RBRACKET, 0)

        def LPAREN(self):
            return self.getToken(CopperParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(CopperParser.RPAREN, 0)

        def DOT(self):
            return self.getToken(CopperParser.DOT, 0)

        def COMMA(self):
            return self.getToken(CopperParser.COMMA, 0)

        def PLUS(self):
            return self.getToken(CopperParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(CopperParser.MINUS, 0)

        def MULTIPLY(self):
            return self.getToken(CopperParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(CopperParser.DIVIDE, 0)

        def EQUALS(self):
            return self.getToken(CopperParser.EQUALS, 0)

        def LESS_THAN(self):
            return self.getToken(CopperParser.LESS_THAN, 0)

        def GREATER_THAN(self):
            return self.getToken(CopperParser.GREATER_THAN, 0)

        def contextualKeyword(self):
            return self.getTypedRuleContext(CopperParser.ContextualKeywordContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_daxToken

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDaxToken" ):
                listener.enterDaxToken(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDaxToken" ):
                listener.exitDaxToken(self)




    def daxToken(self):

        localctx = CopperParser.DaxTokenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_daxToken)
        try:
            self.state = 330
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 313
                self.match(CopperParser.IDENTIFIER)
                pass
            elif token in [CopperParser.NUMBER_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 314
                self.match(CopperParser.NUMBER_LITERAL)
                pass
            elif token in [CopperParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 315
                self.match(CopperParser.STRING_LITERAL)
                pass
            elif token in [CopperParser.LBRACKET]:
                self.enterOuterAlt(localctx, 4)
                self.state = 316
                self.match(CopperParser.LBRACKET)
                pass
            elif token in [CopperParser.RBRACKET]:
                self.enterOuterAlt(localctx, 5)
                self.state = 317
                self.match(CopperParser.RBRACKET)
                pass
            elif token in [CopperParser.LPAREN]:
                self.enterOuterAlt(localctx, 6)
                self.state = 318
                self.match(CopperParser.LPAREN)
                pass
            elif token in [CopperParser.RPAREN]:
                self.enterOuterAlt(localctx, 7)
                self.state = 319
                self.match(CopperParser.RPAREN)
                pass
            elif token in [CopperParser.DOT]:
                self.enterOuterAlt(localctx, 8)
                self.state = 320
                self.match(CopperParser.DOT)
                pass
            elif token in [CopperParser.COMMA]:
                self.enterOuterAlt(localctx, 9)
                self.state = 321
                self.match(CopperParser.COMMA)
                pass
            elif token in [CopperParser.PLUS]:
                self.enterOuterAlt(localctx, 10)
                self.state = 322
                self.match(CopperParser.PLUS)
                pass
            elif token in [CopperParser.MINUS]:
                self.enterOuterAlt(localctx, 11)
                self.state = 323
                self.match(CopperParser.MINUS)
                pass
            elif token in [CopperParser.MULTIPLY]:
                self.enterOuterAlt(localctx, 12)
                self.state = 324
                self.match(CopperParser.MULTIPLY)
                pass
            elif token in [CopperParser.DIVIDE]:
                self.enterOuterAlt(localctx, 13)
                self.state = 325
                self.match(CopperParser.DIVIDE)
                pass
            elif token in [CopperParser.EQUALS]:
                self.enterOuterAlt(localctx, 14)
                self.state = 326
                self.match(CopperParser.EQUALS)
                pass
            elif token in [CopperParser.LESS_THAN]:
                self.enterOuterAlt(localctx, 15)
                self.state = 327
                self.match(CopperParser.LESS_THAN)
                pass
            elif token in [CopperParser.GREATER_THAN]:
                self.enterOuterAlt(localctx, 16)
                self.state = 328
                self.match(CopperParser.GREATER_THAN)
                pass
            elif token in [CopperParser.STRING_TYPE, CopperParser.NUMBER_TYPE, CopperParser.DATE_TYPE, CopperParser.DATE_TIME_TYPE, CopperParser.YESNO_TYPE, CopperParser.TIER_TYPE, CopperParser.BIN_TYPE, CopperParser.LOCATION_TYPE, CopperParser.ZIPCODE_TYPE, CopperParser.DISTANCE_TYPE, CopperParser.DURATION_TYPE, CopperParser.TIME_TYPE, CopperParser.UNQUOTED_TYPE, CopperParser.COUNT_TYPE, CopperParser.SUM_TYPE, CopperParser.AVERAGE_TYPE, CopperParser.MIN_TYPE, CopperParser.MAX_TYPE, CopperParser.COUNT_DISTINCT_TYPE, CopperParser.MEDIAN_TYPE, CopperParser.PERCENTILE_TYPE, CopperParser.LEFT_OUTER, CopperParser.INNER, CopperParser.FULL_OUTER, CopperParser.CROSS, CopperParser.ONE_TO_ONE, CopperParser.MANY_TO_ONE, CopperParser.ONE_TO_MANY, CopperParser.MANY_TO_MANY, CopperParser.USD, CopperParser.EUR, CopperParser.GBP, CopperParser.PERCENT_1, CopperParser.PERCENT_2, CopperParser.DECIMAL_0, CopperParser.DECIMAL_1, CopperParser.DECIMAL_2, CopperParser.ID, CopperParser.MILES, CopperParser.KILOMETERS, CopperParser.METERS, CopperParser.FEET]:
                self.enterOuterAlt(localctx, 17)
                self.state = 329
                self.contextualKeyword()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CopperParser.IDENTIFIER, 0)

        def contextualKeyword(self):
            return self.getTypedRuleContext(CopperParser.ContextualKeywordContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = CopperParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_identifier)
        try:
            self.state = 334
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CopperParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 332
                self.match(CopperParser.IDENTIFIER)
                pass
            elif token in [CopperParser.STRING_TYPE, CopperParser.NUMBER_TYPE, CopperParser.DATE_TYPE, CopperParser.DATE_TIME_TYPE, CopperParser.YESNO_TYPE, CopperParser.TIER_TYPE, CopperParser.BIN_TYPE, CopperParser.LOCATION_TYPE, CopperParser.ZIPCODE_TYPE, CopperParser.DISTANCE_TYPE, CopperParser.DURATION_TYPE, CopperParser.TIME_TYPE, CopperParser.UNQUOTED_TYPE, CopperParser.COUNT_TYPE, CopperParser.SUM_TYPE, CopperParser.AVERAGE_TYPE, CopperParser.MIN_TYPE, CopperParser.MAX_TYPE, CopperParser.COUNT_DISTINCT_TYPE, CopperParser.MEDIAN_TYPE, CopperParser.PERCENTILE_TYPE, CopperParser.LEFT_OUTER, CopperParser.INNER, CopperParser.FULL_OUTER, CopperParser.CROSS, CopperParser.ONE_TO_ONE, CopperParser.MANY_TO_ONE, CopperParser.ONE_TO_MANY, CopperParser.MANY_TO_MANY, CopperParser.USD, CopperParser.EUR, CopperParser.GBP, CopperParser.PERCENT_1, CopperParser.PERCENT_2, CopperParser.DECIMAL_0, CopperParser.DECIMAL_1, CopperParser.DECIMAL_2, CopperParser.ID, CopperParser.MILES, CopperParser.KILOMETERS, CopperParser.METERS, CopperParser.FEET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 333
                self.contextualKeyword()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ContextualKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_TYPE(self):
            return self.getToken(CopperParser.STRING_TYPE, 0)

        def NUMBER_TYPE(self):
            return self.getToken(CopperParser.NUMBER_TYPE, 0)

        def DATE_TYPE(self):
            return self.getToken(CopperParser.DATE_TYPE, 0)

        def DATE_TIME_TYPE(self):
            return self.getToken(CopperParser.DATE_TIME_TYPE, 0)

        def YESNO_TYPE(self):
            return self.getToken(CopperParser.YESNO_TYPE, 0)

        def TIER_TYPE(self):
            return self.getToken(CopperParser.TIER_TYPE, 0)

        def BIN_TYPE(self):
            return self.getToken(CopperParser.BIN_TYPE, 0)

        def LOCATION_TYPE(self):
            return self.getToken(CopperParser.LOCATION_TYPE, 0)

        def ZIPCODE_TYPE(self):
            return self.getToken(CopperParser.ZIPCODE_TYPE, 0)

        def DISTANCE_TYPE(self):
            return self.getToken(CopperParser.DISTANCE_TYPE, 0)

        def DURATION_TYPE(self):
            return self.getToken(CopperParser.DURATION_TYPE, 0)

        def TIME_TYPE(self):
            return self.getToken(CopperParser.TIME_TYPE, 0)

        def UNQUOTED_TYPE(self):
            return self.getToken(CopperParser.UNQUOTED_TYPE, 0)

        def COUNT_TYPE(self):
            return self.getToken(CopperParser.COUNT_TYPE, 0)

        def SUM_TYPE(self):
            return self.getToken(CopperParser.SUM_TYPE, 0)

        def AVERAGE_TYPE(self):
            return self.getToken(CopperParser.AVERAGE_TYPE, 0)

        def MIN_TYPE(self):
            return self.getToken(CopperParser.MIN_TYPE, 0)

        def MAX_TYPE(self):
            return self.getToken(CopperParser.MAX_TYPE, 0)

        def COUNT_DISTINCT_TYPE(self):
            return self.getToken(CopperParser.COUNT_DISTINCT_TYPE, 0)

        def MEDIAN_TYPE(self):
            return self.getToken(CopperParser.MEDIAN_TYPE, 0)

        def PERCENTILE_TYPE(self):
            return self.getToken(CopperParser.PERCENTILE_TYPE, 0)

        def LEFT_OUTER(self):
            return self.getToken(CopperParser.LEFT_OUTER, 0)

        def INNER(self):
            return self.getToken(CopperParser.INNER, 0)

        def FULL_OUTER(self):
            return self.getToken(CopperParser.FULL_OUTER, 0)

        def CROSS(self):
            return self.getToken(CopperParser.CROSS, 0)

        def ONE_TO_ONE(self):
            return self.getToken(CopperParser.ONE_TO_ONE, 0)

        def MANY_TO_ONE(self):
            return self.getToken(CopperParser.MANY_TO_ONE, 0)

        def ONE_TO_MANY(self):
            return self.getToken(CopperParser.ONE_TO_MANY, 0)

        def MANY_TO_MANY(self):
            return self.getToken(CopperParser.MANY_TO_MANY, 0)

        def USD(self):
            return self.getToken(CopperParser.USD, 0)

        def EUR(self):
            return self.getToken(CopperParser.EUR, 0)

        def GBP(self):
            return self.getToken(CopperParser.GBP, 0)

        def PERCENT_1(self):
            return self.getToken(CopperParser.PERCENT_1, 0)

        def PERCENT_2(self):
            return self.getToken(CopperParser.PERCENT_2, 0)

        def DECIMAL_0(self):
            return self.getToken(CopperParser.DECIMAL_0, 0)

        def DECIMAL_1(self):
            return self.getToken(CopperParser.DECIMAL_1, 0)

        def DECIMAL_2(self):
            return self.getToken(CopperParser.DECIMAL_2, 0)

        def ID(self):
            return self.getToken(CopperParser.ID, 0)

        def MILES(self):
            return self.getToken(CopperParser.MILES, 0)

        def KILOMETERS(self):
            return self.getToken(CopperParser.KILOMETERS, 0)

        def METERS(self):
            return self.getToken(CopperParser.METERS, 0)

        def FEET(self):
            return self.getToken(CopperParser.FEET, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_contextualKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContextualKeyword" ):
                listener.enterContextualKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContextualKeyword" ):
                listener.exitContextualKeyword(self)




    def contextualKeyword(self):

        localctx = CopperParser.ContextualKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_contextualKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            _la = self._input.LA(1)
            if not(((((_la - 23)) & ~0x3f) == 0 and ((1 << (_la - 23)) & ((1 << (CopperParser.STRING_TYPE - 23)) | (1 << (CopperParser.NUMBER_TYPE - 23)) | (1 << (CopperParser.DATE_TYPE - 23)) | (1 << (CopperParser.DATE_TIME_TYPE - 23)) | (1 << (CopperParser.YESNO_TYPE - 23)) | (1 << (CopperParser.TIER_TYPE - 23)) | (1 << (CopperParser.BIN_TYPE - 23)) | (1 << (CopperParser.LOCATION_TYPE - 23)) | (1 << (CopperParser.ZIPCODE_TYPE - 23)) | (1 << (CopperParser.DISTANCE_TYPE - 23)) | (1 << (CopperParser.DURATION_TYPE - 23)) | (1 << (CopperParser.TIME_TYPE - 23)) | (1 << (CopperParser.UNQUOTED_TYPE - 23)) | (1 << (CopperParser.COUNT_TYPE - 23)) | (1 << (CopperParser.SUM_TYPE - 23)) | (1 << (CopperParser.AVERAGE_TYPE - 23)) | (1 << (CopperParser.MIN_TYPE - 23)) | (1 << (CopperParser.MAX_TYPE - 23)) | (1 << (CopperParser.COUNT_DISTINCT_TYPE - 23)) | (1 << (CopperParser.MEDIAN_TYPE - 23)) | (1 << (CopperParser.PERCENTILE_TYPE - 23)) | (1 << (CopperParser.LEFT_OUTER - 23)) | (1 << (CopperParser.INNER - 23)) | (1 << (CopperParser.FULL_OUTER - 23)) | (1 << (CopperParser.CROSS - 23)) | (1 << (CopperParser.ONE_TO_ONE - 23)) | (1 << (CopperParser.MANY_TO_ONE - 23)) | (1 << (CopperParser.ONE_TO_MANY - 23)) | (1 << (CopperParser.MANY_TO_MANY - 23)) | (1 << (CopperParser.USD - 23)) | (1 << (CopperParser.EUR - 23)) | (1 << (CopperParser.GBP - 23)) | (1 << (CopperParser.PERCENT_1 - 23)) | (1 << (CopperParser.PERCENT_2 - 23)) | (1 << (CopperParser.DECIMAL_0 - 23)) | (1 << (CopperParser.DECIMAL_1 - 23)) | (1 << (CopperParser.DECIMAL_2 - 23)) | (1 << (CopperParser.ID - 23)) | (1 << (CopperParser.MILES - 23)) | (1 << (CopperParser.KILOMETERS - 23)) | (1 << (CopperParser.METERS - 23)) | (1 << (CopperParser.FEET - 23)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(CopperParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_stringLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)




    def stringLiteral(self):

        localctx = CopperParser.StringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_stringLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(CopperParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER_LITERAL(self):
            return self.getToken(CopperParser.NUMBER_LITERAL, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_numberLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteral" ):
                listener.enterNumberLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteral" ):
                listener.exitNumberLiteral(self)




    def numberLiteral(self):

        localctx = CopperParser.NumberLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_numberLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.match(CopperParser.NUMBER_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanLiteral(self):
            return self.getTypedRuleContext(CopperParser.BooleanLiteralContext,0)


        def getRuleIndex(self):
            return CopperParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = CopperParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_booleanValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.booleanLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BooleanLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(CopperParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(CopperParser.FALSE, 0)

        def YES(self):
            return self.getToken(CopperParser.YES, 0)

        def NO(self):
            return self.getToken(CopperParser.NO, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_booleanLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)




    def booleanLiteral(self):

        localctx = CopperParser.BooleanLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_booleanLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (CopperParser.TRUE - 65)) | (1 << (CopperParser.FALSE - 65)) | (1 << (CopperParser.YES - 65)) | (1 << (CopperParser.NO - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FormatNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USD(self):
            return self.getToken(CopperParser.USD, 0)

        def EUR(self):
            return self.getToken(CopperParser.EUR, 0)

        def GBP(self):
            return self.getToken(CopperParser.GBP, 0)

        def PERCENT_1(self):
            return self.getToken(CopperParser.PERCENT_1, 0)

        def PERCENT_2(self):
            return self.getToken(CopperParser.PERCENT_2, 0)

        def DECIMAL_0(self):
            return self.getToken(CopperParser.DECIMAL_0, 0)

        def DECIMAL_1(self):
            return self.getToken(CopperParser.DECIMAL_1, 0)

        def DECIMAL_2(self):
            return self.getToken(CopperParser.DECIMAL_2, 0)

        def ID(self):
            return self.getToken(CopperParser.ID, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_formatName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormatName" ):
                listener.enterFormatName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormatName" ):
                listener.exitFormatName(self)




    def formatName(self):

        localctx = CopperParser.FormatNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_formatName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CopperParser.USD) | (1 << CopperParser.EUR) | (1 << CopperParser.GBP) | (1 << CopperParser.PERCENT_1) | (1 << CopperParser.PERCENT_2) | (1 << CopperParser.DECIMAL_0) | (1 << CopperParser.DECIMAL_1) | (1 << CopperParser.DECIMAL_2) | (1 << CopperParser.ID))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnitsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MILES(self):
            return self.getToken(CopperParser.MILES, 0)

        def KILOMETERS(self):
            return self.getToken(CopperParser.KILOMETERS, 0)

        def METERS(self):
            return self.getToken(CopperParser.METERS, 0)

        def FEET(self):
            return self.getToken(CopperParser.FEET, 0)

        def getRuleIndex(self):
            return CopperParser.RULE_units

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnits" ):
                listener.enterUnits(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnits" ):
                listener.exitUnits(self)




    def units(self):

        localctx = CopperParser.UnitsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_units)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            _la = self._input.LA(1)
            if not(((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & ((1 << (CopperParser.MILES - 61)) | (1 << (CopperParser.KILOMETERS - 61)) | (1 << (CopperParser.METERS - 61)) | (1 << (CopperParser.FEET - 61)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CopperParser.IdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CopperParser.COMMA)
            else:
                return self.getToken(CopperParser.COMMA, i)

        def getRuleIndex(self):
            return CopperParser.RULE_identifierList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierList" ):
                listener.enterIdentifierList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierList" ):
                listener.exitIdentifierList(self)




    def identifierList(self):

        localctx = CopperParser.IdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_identifierList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.identifier()
            self.state = 355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CopperParser.COMMA:
                self.state = 351
                self.match(CopperParser.COMMA)
                self.state = 352
                self.identifier()
                self.state = 357
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StringListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(CopperParser.StringLiteralContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CopperParser.COMMA)
            else:
                return self.getToken(CopperParser.COMMA, i)

        def getRuleIndex(self):
            return CopperParser.RULE_stringList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringList" ):
                listener.enterStringList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringList" ):
                listener.exitStringList(self)




    def stringList(self):

        localctx = CopperParser.StringListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_stringList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self.stringLiteral()
            self.state = 363
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CopperParser.COMMA:
                self.state = 359
                self.match(CopperParser.COMMA)
                self.state = 360
                self.stringLiteral()
                self.state = 365
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CopperParser.NumberLiteralContext)
            else:
                return self.getTypedRuleContext(CopperParser.NumberLiteralContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(CopperParser.COMMA)
            else:
                return self.getToken(CopperParser.COMMA, i)

        def getRuleIndex(self):
            return CopperParser.RULE_numberList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberList" ):
                listener.enterNumberList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberList" ):
                listener.exitNumberList(self)




    def numberList(self):

        localctx = CopperParser.NumberListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_numberList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 366
            self.numberLiteral()
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CopperParser.COMMA:
                self.state = 367
                self.match(CopperParser.COMMA)
                self.state = 368
                self.numberLiteral()
                self.state = 373
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





