# DAX Expression Grammar (EBNF)
# Grammar for DAX (Data Analysis Expressions) used in Copper

# Main DAX Expression
dax_expression = 
    var_statement |
    dax_logical_expression ;

# Variable Declaration with VAR/RETURN
var_statement = "VAR" identifier "=" dax_expression { newline var_statement } newline "RETURN" dax_expression ;

# Logical Expressions (highest precedence)
dax_logical_expression = dax_comparison_expression { logical_operator dax_comparison_expression } ;

logical_operator = "&&" | "||" | "AND" | "OR" ;

# Comparison Expressions
dax_comparison_expression = dax_arithmetic_expression { comparison_operator dax_arithmetic_expression } ;

comparison_operator = "=" | "<>" | "!=" | "<" | ">" | "<=" | ">=" | "IN" ;

# Arithmetic Expressions
dax_arithmetic_expression = dax_term { arithmetic_operator dax_term } ;

arithmetic_operator = "+" | "-" | "*" | "/" | "^" ;

# Terms (atoms of DAX expressions)
dax_term =
    dax_function_call |
    column_reference |
    related_reference |
    table_reference |
    measure_reference |
    number_literal |
    string_literal |
    boolean_literal |
    date_literal |
    variable_reference |
    parenthesized_expression ;

parenthesized_expression = "(" dax_expression ")" ;

# Function Calls
dax_function_call = function_name "(" [ dax_argument_list ] ")" ;

dax_argument_list = dax_expression { "," dax_expression } ;

# Table and Column References
table_reference = table_name ;

column_reference = table_name "[" column_name "]" ;

related_reference = "RELATED" "(" column_reference ")" ;

related_table_reference = "RELATEDTABLE" "(" table_name ")" ;

measure_reference = "[" measure_name "]" ;

variable_reference = identifier ;

# DAX Function Categories

# Aggregation Functions
aggregation_function = 
    "SUM" | "SUMX" | "COUNT" | "COUNTA" | "COUNTX" | "COUNTROWS" | "COUNTBLANK" |
    "AVERAGE" | "AVERAGEX" | "MIN" | "MINX" | "MAX" | "MAXX" |
    "DISTINCTCOUNT" | "DISTINCTCOUNTNOBLANK" |
    "MEDIAN" | "PERCENTILE.EXC" | "PERCENTILE.INC" |
    "STDEV.P" | "STDEV.S" | "VAR.P" | "VAR.S" ;

# Filter Functions
filter_function =
    "CALCULATE" | "CALCULATETABLE" | "FILTER" | "ALL" | "ALLEXCEPT" | "ALLSELECTED" |
    "VALUES" | "DISTINCT" | "EARLIER" | "EARLIEST" | "HASONEVALUE" | "HASONEFILTER" |
    "ISCROSSFILTERED" | "ISFILTERED" | "SELECTEDVALUE" | "USERRELATIONSHIP" ;

# Logical Functions
logical_function =
    "IF" | "IFERROR" | "IFNA" | "SWITCH" | "TRUE" | "FALSE" |
    "AND" | "OR" | "NOT" | "BLANK" | "ISBLANK" | "ISEMPTY" | "ISNUMBER" | "ISTEXT" ;

# Mathematical Functions
math_function =
    "ABS" | "CEILING" | "FLOOR" | "ROUND" | "ROUNDUP" | "ROUNDDOWN" | "TRUNC" |
    "MOD" | "QUOTIENT" | "DIVIDE" | "POWER" | "SQRT" | "EXP" | "LN" | "LOG" | "LOG10" |
    "SIGN" | "PI" | "DEGREES" | "RADIANS" | "SIN" | "COS" | "TAN" | "ASIN" | "ACOS" | "ATAN" ;

# Text Functions
text_function =
    "CONCATENATE" | "CONCATENATEX" | "LEFT" | "RIGHT" | "MID" | "LEN" | "TRIM" |
    "UPPER" | "LOWER" | "PROPER" | "SUBSTITUTE" | "REPLACE" | "REPT" |
    "FIND" | "SEARCH" | "EXACT" | "FORMAT" | "VALUE" | "UNICHAR" | "UNICODE" ;

# Date/Time Functions
datetime_function =
    "DATE" | "TIME" | "DATETIME" | "NOW" | "TODAY" | "UTCNOW" | "UTCTODAY" |
    "YEAR" | "MONTH" | "DAY" | "HOUR" | "MINUTE" | "SECOND" | "WEEKDAY" | "WEEKNUM" |
    "DATEDIFF" | "DATEADD" | "EOMONTH" | "EDATE" |
    "STARTOFYEAR" | "ENDOFYEAR" | "STARTOFQUARTER" | "ENDOFQUARTER" |
    "STARTOFMONTH" | "ENDOFMONTH" | "STARTOFWEEK" | "ENDOFWEEK" |
    "FIRSTDATE" | "LASTDATE" | "NEXTDAY" | "PREVIOUSDAY" | "NEXTMONTH" | "PREVIOUSMONTH" |
    "NEXTYEAR" | "PREVIOUSYEAR" | "SAMEPERIODLASTYEAR" |
    "TOTALYTD" | "TOTALQTD" | "TOTALMTD" | "DATESYTD" | "DATESQTD" | "DATESMTD" |
    "DATESINPERIOD" | "DATESBETWEEN" | "PARALLELPERIOD" | "CALENDARAUTO" | "CALENDAR" ;

# Table Functions
table_function =
    "ADDCOLUMNS" | "SELECTCOLUMNS" | "SUMMARIZE" | "SUMMARIZECOLUMNS" | "GROUPBY" |
    "TOPN" | "SAMPLE" | "DATATABLE" | "ROW" | "UNION" | "INTERSECT" | "EXCEPT" |
    "NATURALINNERJOIN" | "NATURALLEFTOUTERJOIN" | "CROSSJOIN" |
    "GENERATE" | "GENERATEALL" | "GENERATESERIES" ;

# Information Functions
info_function =
    "COLUMNCOUNT" | "CONTAINS" | "CONTAINSROW" | "CONTAINSSTRING" | "CONTAINSSTRINGEXACT" |
    "COUNTROWS" | "CUSTOMDATA" | "ERROR" | "HASONEFILTER" | "HASONEVALUE" |
    "ISAFTER" | "ISBLANK" | "ISCROSSFILTERED" | "ISEMPTY" | "ISINSCOPE" | "ISLOGICAL" |
    "ISNUMBER" | "ISONORAFTER" | "ISSELECTEDMEASURE" | "ISSUBTOTAL" | "ISTEXT" |
    "PATH" | "PATHCONTAINS" | "PATHITEM" | "PATHITEMREVERSE" | "PATHLENGTH" |
    "USERNAME" | "USERPRINCIPALNAME" ;

# Statistical Functions
statistical_function =
    "BETA.DIST" | "BETA.INV" | "CHISQ.DIST" | "CHISQ.DIST.RT" | "CHISQ.INV" | "CHISQ.INV.RT" |
    "CONFIDENCE.NORM" | "CONFIDENCE.T" | "EXPON.DIST" | "GEOMEAN" | "NORM.DIST" | "NORM.INV" |
    "NORM.S.DIST" | "NORM.S.INV" | "POISSON.DIST" | "T.DIST" | "T.DIST.2T" | "T.DIST.RT" |
    "T.INV" | "T.INV.2T" | "WEIBULL.DIST" ;

# Financial Functions
financial_function =
    "ACCRINT" | "ACCRINTM" | "AMORDEGRC" | "AMORLINC" | "COUPDAYBS" | "COUPDAYS" |
    "COUPDAYSNC" | "COUPNCD" | "COUPNUM" | "COUPPCD" | "CUMIPMT" | "CUMPRINC" |
    "DB" | "DDB" | "DISC" | "DOLLARDE" | "DOLLARFR" | "DURATION" | "EFFECT" |
    "FV" | "FVSCHEDULE" | "INTRATE" | "IPMT" | "IRR" | "ISPMT" | "MDURATION" |
    "MIRR" | "NOMINAL" | "NPER" | "NPV" | "ODDFPRICE" | "ODDFYIELD" | "ODDLPRICE" |
    "ODDLYIELD" | "PMT" | "PPMT" | "PRICE" | "PRICEDISC" | "PRICEMAT" | "PV" |
    "RATE" | "RECEIVED" | "SLN" | "SYD" | "TBILLEQ" | "TBILLPRICE" | "TBILLYIELD" |
    "VDB" | "XIRR" | "XNPV" | "YIELD" | "YIELDDISC" | "YIELDMAT" ;

# All Function Names
function_name =
    aggregation_function |
    filter_function |
    logical_function |
    math_function |
    text_function |
    datetime_function |
    table_function |
    info_function |
    statistical_function |
    financial_function |
    identifier ;

# Literals
number_literal = [ "-" ] ( integer_literal | decimal_literal | scientific_literal ) ;

integer_literal = digit { digit } ;

decimal_literal = digit { digit } "." digit { digit } ;

scientific_literal = ( integer_literal | decimal_literal ) ( "E" | "e" ) [ "+" | "-" ] digit { digit } ;

string_literal = "\"" { string_character } "\"" ;

string_character = 
    any_character - ( "\"" | "\\" ) |
    "\\" ( "\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t" | "u" hex_digit hex_digit hex_digit hex_digit ) ;

boolean_literal = "TRUE" | "FALSE" | "true" | "false" ;

date_literal = 
    "DATE" "(" year "," month "," day ")" |
    "DATETIME" "(" year "," month "," day "," hour "," minute "," second ")" |
    "TIME" "(" hour "," minute "," second ")" ;

year = digit digit digit digit ;
month = digit { digit } ;
day = digit { digit } ;
hour = digit { digit } ;
minute = digit { digit } ;
second = digit { digit } ;

# Identifiers and Names
identifier = letter { letter | digit | "_" } ;

table_name = 
    "'" table_name_character { table_name_character } "'" |
    identifier ;

table_name_character = any_character - "'" | "''" ;

column_name = 
    "[" column_name_character { column_name_character } "]" |
    identifier ;

column_name_character = any_character - ( "[" | "]" ) | "]]" | "[[" ;

measure_name = identifier ;

# Special Operators and Keywords
in_operator = "IN" "{" dax_expression { "," dax_expression } "}" ;

# Comments (single line only in DAX)
dax_comment = "//" { any_character } newline ;

# Basic Character Classes
letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" |
         "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" |
         "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" |
         "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

hex_digit = digit | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" ;

any_character = ? any Unicode character ? ;

newline = "\n" | "\r\n" | "\r" ;

whitespace = " " | "\t" | newline ;

# Note: Whitespace is typically ignored between tokens in DAX expressions